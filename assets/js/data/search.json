[ { "title": "React란?", "url": "/posts/introduction-of-react/", "categories": "Web, React", "tags": "react", "date": "2022-07-06 10:01:00 +0900", "snippet": "이번 포스트에서는 리액트란 무엇인지 알아보고 프로젝트를 생성하는 것 까지를 다루겠습니다React?공식적으로 리액트는 사용자 인터페이스를 만들기 위한 라이브러리 입니다. 리액트는 프레임워크가 아니며, 심지어 웹에서만 사용할 수 있는 것도 아닙니다.리액트는 다른 라이브러리들과 함께 특정 환경을 렌더링하는 데 사용됩니다.예를 들면, 웹 환경에서는 React, 모바일 환경에서는 React-Native, VR 환경은 React 360을 사용하여 구현이 가능합니다. React360의 경우 2020년 이후 PR, Issue 등이 업데이트되지 않고 있습니다.아무래도 VR을 구현하기에 좋은 프레임워크가 많기 때문이라 추측됩니다.웹을 만들 때는 ReactDOM과 함께 사용합니다. React + ReactDOM은 Vue와 같은 프레임워크와 동일한 문제를 해결하기 위해 사용됩니다.React의 사용NextJS와 같은 프레임워크와 달리, 리액트는 코드 컨벤션이나 파일 구조에 엄격한 규칙을 가지지 않습니다.즉, 리액트로 구현할 수 있는 범위는 자유로워서, 하나의 버튼, 인터페이스의 일부분, 심지어는 애플리케이션의 전체를 구현할 수도 있습니다. 대부분의 프레임워크나 JQuery 라이브러리와 달리, 다른 프레임워크나 라이브러리로 구현된 프로젝트에 리액트로 구현된 코드를 이식하는 것이 매우 어렵습니다.리액트는 애플리케이션 전체를 구현할 때 사용하는 것이 쉬운 접근 방법입니다.리액트를 시작하는 방법은 React, ReactDOM 및 필요한 구성 요소를 직접 구성하는 방법과 create-react-app(CRA)를 사용하는 방법 두 가지가 있습니다.이번 포스트에서는 CRA를 이용하여 프로젝트를 생성하는 것 까지 알아보도록 하겠습니다.필요한 환경Node.jsCRA를 사용하기 위해서는 Node.js가 필수적으로 필요합니다.Node.js 버전은 LTS(Long-Term Support) 버전을 사용하는 것을 추천합니다. 안정적이며 오래 지원하기 때문이죠. 2022.07.06 기준 LTS 버전은 16.15.1 이며다운로드 링크는 Node.js Download 입니다.해당 포스트에서는 Node.js 설치 방법을 설명하지는 않습니다. 필요하다고 판단되면 추후 다른 포스트에서 다루겠습니다.Node.js를 설치하게 되면 npx, npm이 함께 설치되는데, 간단하게 알아보도록 하겠습니다.npmNPM은 Node Package Manager의 약자로 npm repository에서 패키지를 다운로드할 수 있으며, 이러한 모듈들을 npm script에 명시하여 프로젝트의 Node 모듈을 관리하는 역할을 수행합니다.아래의 명령어와 같이 사용되며, 실행 후 프로젝트 root에 node_modules 라는 폴더가 생성되어 관리하게 됩니다.# dependencynpm install $PACKAGE_NAME# devDependencynpm install $PACKAGE_NAME --save-devdependency 및 devDependency의 경우 추후 package.json에 대한 포스트에서 다루도록 하겠습니다. NPM과 비슷한 역할의 패키지 매니저인 YARN이 있습니다.npx시스템 전역적으로 Node 모듈을 설치하여 사용해야할 때, 과거에는 다음과 같이 전역에 Node 모듈을 설치하여 실행했습니다.# -g -&gt; Global optionnpm install $PACKAGE_NAME -g이러한 방법은 여전히 유용하지만, 일시적으로 사용하는 모듈을 매번 로컬에 설치하는 것은 곧 공간의 낭비로 이어집니다.npm 5.2 버전부터 npx라는 도구를 지원합니다.간단하게 설명하면 Node 모듈을 임시로 설치하여 실행하고, 실행 후 자동으로 fallback 되어 패키지는 사라지게 됩니다.로컬 전역에 사용될 node_modules 폴더를 관리할 필요도 없고 공간을 절약할 수 있음을 알 수 있습니다.프로젝트 생성환경에서 살펴본 npx를 이용하여 프로젝트를 생성하겠습니다.npx create-react-app $PROJECT_NAME위의 명령어를 수행하면 기본적인 리액트 프로젝트가 생성됩니다.마무리다음 포스트에서는 리액트 프로젝트의 구조와 관리에 대해서 작성하도록 하겠습니다." }, { "title": "WebAssembly 만들기", "url": "/posts/make-wasm/", "categories": "Web, WebAssembly", "tags": "wasm", "date": "2022-07-01 17:18:00 +0900", "snippet": "이번 포스팅에서는 C/C++ 언어로 작성된 웹어셈블리 파일(.wasm)을 생성하는 방법을 알아보겠습니다사용할 도구EmscriptenC/C++ 언어를 웹어셈블리로 변환하는 컴파일러입니다지금부터 Emscripten SDK의 설치 방법을 알아보겠습니다 공식 권장 환경은 Linux/MacOS 입니다윈도우를 사용하시는 개발자 분이라도 WSL2를 이용하여 리눅스 환경에서 작업하시는 것을 권장 드립니다만, 윈도우 환경에서의 설정도 알아보도록 하겠습니다설치 순서Python 설치Emscripten 실행을 위해서는 파이썬 3.6 이상의 버전이 필요합니다파이썬 설치 방법은 따로 안내하지는 않겠습니다Emscripten SDK Download &amp; Install먼저 git clone을 통해 emscripten SDK를 받습니다git clone https://github.com/emscripten-core/emsdk 혹은 Emscripten github에서 zip 형태로 다운로드 받는 방법도 있습니다clone 위치 혹은 다운로드 받은 zip을 압축 해제한 경로로 이동하여 설치를 진행하고, 환경 변수 설정을 해야 합니다.윈도우와 리눅스/맥의 경우 환경설정 파일이 다르므로 따로 나눠서 설명하겠습니다.# Windows (Powershell)## emsdk 폴더로 이동cd emsdk## 설치.\\emsdk install latest## 환경변수 등록.\\emsdk_env.bat## 설치 &amp; 버전 확인emcc --version# Linux/MacOS## 절차는 윈도우에서와 동일cd emsdk./emsdk install latestsource emsdk_env.shemcc --version버전 정보가 잘 나오면 정상적으로 설치된 것입니다.이제 C/C++로 작성된 코드를 웹어셈블리로 만들 준비가 끝났습니다!Make WebAssembly아래의 예시 코드를 웹어셈블리로 만드는 과정을 함께 따라가보겠습니다#include &lt;stdio.h&gt;int add(int num1, int num2) { return num1 + num2;}두 정수를 인자로 받아서 그 합을 반환하는 단순한 덧셈 코드입니다.코드 수정C/C++ 코드를 웹어셈블리로 컴파일하기 위해서는 아래의 두 가지 작업이 필요합니다. Header 추가 예약어 추가코드로 확인해보겠습니다.#include &lt;stdio.h&gt;// EMSCRIPTEN_KEEPALIVE 를 사용하기 위해 필요한 헤더#include &lt;emscripten.h&gt;// 예약어 추가EMSCRIPTEN_KEEPALIVEint add(int num1, int num2) { return num1 + num2;} EMSCRIPTEN_KEEPALIVE?기본적으로 Emscripten이 생성한 코드는 항상 main()함수를 호출하고 다른 함수는 불필요한 코드로 제거됩니다.EMSCRIPTEN_KEEPALIVE 예약어를 함수 앞에 사용하게 되면 해당 함수는 데드코드로 제거되지 않습니다.실제 호출해서 사용할 함수들에는 잊지 않고 작성하도록 해야겠습니다.빌드크게 두 가지로 나누어 생각해 보겠습니다. WebAssembly file + glue javascript Only WebAssembly file회사에서 프로젝트를 진행할 때, 외부 이식성을 고려하여 js 파일을 생성하지 않고 wasm 파일만 생성되도록 방향을 잡았었습니다.이번 포스팅에서는 제가 진행했던 방식을 소개하고, 추후 Rust를 이용한 웹어셈블리 생성을 정리할 때 js 파일을 함께 소개하도록 하겠습니다.먼저, 여러 파일로 분리된 C/C++ 프로젝트를 모두 오브젝트 파일로 컴파일 합니다. 저는 cmake를 사용하여 진행했습니다.하나의 프로젝트가 여러 파일로 분산되어 있는 경우, cmake를 통해 make 파일을 생성하는 것이 좋은 방법입니다.자세한 cmake 사용 방법은 추후 다른 포스트에서 다루도록 하고, 이번 포스트에서는 필자가 회사에서 사용하던 방법을 안내하도록 하겠습니다.먼저 CMakeLists.txt파일을 작성합니다.# CMakeLists.txtCMAKE_MINIMUM_REQUIRED ( VERSION 3.16 )PROJECT ( \"CRYPTO\" ) # Project name 정의SET ( PROJECT_VERSION_MAJOR 0 )SET ( PROJECT_VERSION_MINOR 1 )SET ( CMAKE_BUILD_TYPE Debug )SET ( CMAKE_VERBOSE_MAKEFILE true )SET ( CMAKE_C_COMPILER \"emcc\" ) # 컴파일러 정의FILE ( GLOB SRC_FILES ./*.c ) # 대상 정의ADD_LIBRARY( crypto OBJECT ${SRC_FILES} ) # 최종 산출물을 오브젝트 파일로 정의cmake를 이용하여 실제 컴파일을 수행할 make 파일을 만드는데, 이 때 필요한 파일이 CMakeLists.txt 입니다.아래의 명령어로 cmake를 수행하면 실제 빌드에 필요한 Makefile이 생성되고, make 명령어로 빌드를 진행할 수 있습니다.cmake CMakeLists.txt# Make file 생성makemake 명령어를 수행하면, 수행한 디렉토리 내에 CMakeFiles 라는 폴더가 생성되고 내부에 CMakeLists.txt에서 정의한 {라이브러리 이름}.dir의 이름을 가진 폴더가 생성됩니다. 이 예시에서는 CMakeFiles/crypto.dir이 되겠죠?이후 폴더 내부로 진입하여 아래의 명령어를 수행하면 웹어셈블리 파일이 생성됩니다.emcc ./*.o -O1 --no-entry -o crypto.wasm# crypto.wasm은 최종적으로 나오게 되는 웹어셈블리 파일 이름이 됩니다. 원하는 파일 명을 입력하면 되겠습니다.# 컴파일러 옵션 중 -O1은 최적화 레벨을 의미하고, -no-entry의 경우 단독 웹어셈블리 파일 생성을 의미합니다.# 더 많은 옵션이 있으며 공식 사이트에서 확인 바랍니다.여기까지 기존 C/C++ 프로젝트를 웹어셈블리 파일로 만드는 것을 알아봤습니다.글루 코드를 생성하는 방법과 Rust를 이용하는 방법 등 아직 정리하지 못한 부분이 많네요. 추후 포스트에서 다루도록 하겠습니다." }, { "title": "WebAssembly란", "url": "/posts/webassembly/", "categories": "Web, WebAssembly", "tags": "wasm", "date": "2022-06-30 13:12:00 +0900", "snippet": "이번 포스팅에서는 WebAssembly에 대해 알아보도록 하겠습니다WebAssembly란?MDN 문서에 따르면, “최신 웹 브라우저에서 실행할 수 있는 새로운 유형의 코드” 라고 소개하고 있습니다.웹어셈블리는 기존에 사용하던 C, C++, Rust 같은 low-level 언어를 컴파일하여 생성하게 됩니다.즉, 사용하기 위해 새로운 언어를 익히는 개념이 아니라, 기존에 사용하던 언어를 웹에 올려서 사용할 수 있는 코드 정도로 이해하시면 됩니다.그렇다면, 단순히 코드를 재사용할 수 있다 라는 장점만 있을까요? 이 점도 충분히 사용하기에 매력적인 이유지만, 가장 매력적인 부분은 아닙니다. 웹어셈블리의 가장 매력적인 점은 Native에 근접한 성능에 있습니다왜 빠를까?브라우저에서 웹어셈블리는 자바스크립트와는 다른 방식으로 처리되기 때문에 성능의 차이가 발생하게 됩니다.아래 그림으로 처리 방식의 차이를 살펴보겠습니다.자바스크립트의 처리 과정​웹어셈블리의 처리 과정​각 과정들을 살펴보며 어떤 차이가 있는지 알아보겠습니다Parsing구문해석 단계입니다. 자바스크립트 파일이 브라우저에 전달되면, 해당 파일은 *추상 구문 트리(AST: Abstract Syntax Tree)로 변환이 되고, AST로부터 바이트 코드를 생성합니다. 반면 웹어셈블리는 생성된 시점에 이미 바이트 코드의 형태이므로 앞의 변환 과정 없이 해석(decode)과 검증만 거치면 됩니다. 추상 구문 트리(Abstract Syntax Tree) - 컴파일러에서 널리 사용되는 자료구조로, 프로그램의 중간 표현의 역할을 합니다Compile &amp; Optimize컴파일 및 최적화 작업으로, 자바스크립트와 웹어셈블리 모두 거치는 과정입니다. 다만 웹어셈블리의 경우, 웹어셈블리 생성 시 컴파일러에서 최적화를 진행할 수 있기 때문에 브라우저에 올라갈 때 최적화에 들어가는 비용이 자바스크립트에 비해 적습니다.Re-optimize재-최적화 과정으로, 자바스크립트 처리 과정에만 있는 절차이며, 모호한 타입 등 여러 이유로 인해 JIT(Just-In-Time) 컴파일러를 사용하는 과정에서 기존 최적화를 철회하고 다시 최적화를 하는 과정입니다. 웹어셈블리의 경우 타입 등이 명시적이기 때문에 재-최적화를 거칠 필요가 없다고 합니다.Execute해석 및 컴파일, 최적화 과정을 거친 파일을 실행하는 절차입니다. 자바스크립트의 경우 빠르게 실행하기 위해서는 JIT을 자세히 알고, 이에 친화적인 패턴으로 코드를 작성해야 합니다. 그러나 실제로 컴파일러의 동작을 알기란 쉽지 않고, 모든 브라우저에서 동일하게 적용되지 않는 문제가 있습니다. 웹어셈블리의 경우 컴파일러를 위해 최적화가 되어 있기 때문에 일반적으로 더 나은 성능을 기대할 수 있습니다.Garbage collection가비지 컬렉션이란, 가비지 컬렉터(Garbage collector)가 더 이상 필요없는/사용하지 않는 오래된 변수들을 메모리에서 제거하는 작업을 자동으로 수행하는 것을 의미합니다. 개발자 입장에서는 할당한 메모리의 해제를 걱정하지 않고 코드를 작성할 수 있다는 이점이 있지만, 직접 가비지 컬렉터를 제어할 수 없기 때문에 순간적인 메모리 오버플로나, 해제되어야 하는데 유지되는 메모리 누수 등의 문제가 나타날 수 있습니다. 웹어셈블리는 아직 가비지 컬렉션을 지원하지 않는 언어로 작성을 하기 때문에 이러한 문제에서 자유롭습니다.  이러한 차이들에 의해서 일반적으로 웹어셈블리가 자바스크립트에 비해 좋은 성능을 낸다고 합니다. 때문에 복잡한 연산이 들어가는 게임이나 머신러닝 코드도 웹으로 구현이 가능하다고 합니다.그렇다면 웹어셈블리만 사용하면 되지, 왜 자바스크립트는 여전히 쓰일까요?단점언어의 장벽필자는 C/C++을 메인으로 오랜 기간 일을 했으며, 개인적인 취미로 Rust를 익혀왔습니다. 때문에 필자가 웹어셈블리를 접했을 때는 환경 구성만 신경쓰면 됐습니다.그러나 보통의 웹 개발자 라면 이러한 low-level 언어에 익숙하지 않을 수 있습니다. 자바스크립트로 프론트엔드, 백엔드를 모두 구현할 수 있는 지금의 상황에서는 더욱 그럴 것이라고 생각합니다. 이 유형의 개발자 분들은 웹어셈블리 사용을 위해 추가적인 문법 학습이 필요합니다.자바스크립트와 같은 명시적인 타입이 없는 언어에서, 타입이 있는 언어를 익히는 것은 생각보다 어려울 것입니다.제한된 지원 범위가장 널리 사용하는 도구인 Emscripten에서는 number, string, array 타입만을 지원합니다. 특히 array 타입의 경우 웹어셈블리와 자바스크립트 간에 데이터를 전달할 때는 포인터 형태로 변경해야하므로, 실질적으로는 number 타입으로 봐야할 것입니다. 타입의 제한은 활용 방안의 제한으로 이어지게 됩니다.적은 참고자료처음 웹어셈블리를 접할 때 가장 어려웠던 것이 참고자료였습니다. 개발 환경과 언어가 통합된 형태가 아닌 여러 가지가 있다보니 발생할 수 있는 에러의 범위도 넓게 나타납니다. 현재까지 현업에서 사용하는 사례가 적어서(특히나 한국에서는 더…) 에러 해결 등을 위한 참고 자료도 부족한 상태입니다.성능장점 아닌가? 하는 항목일 것입니다. 수행 면만 봤을 때는 거의 항상 웹어셈블리가 빠른 모습을 보입니다. 다만 자바스크립트와 크게 차이가 나지 않는 로직의 경우, 자바스크립트로만 구성된 코드가 빠르게 수행되는 것을 볼 수 있습니다.이는 웹어셈블리가 처음 실행되기 전 적재되는 부분이 있기 때문입니다. 비교적 간단한 계산 로직 등에 무조건 웹어셈블리를 적용하는 것은 자칫 웹 성능을 떨어뜨리는 원흉이 될 수 있습니다.마치며웹어셈블리가 무엇이며 자바스크립트와 비교해서 어떠한 장점과 단점이 있는지 살펴봤습니다.이후 포스팅에서는 실제로 웹어셈블리를 만드는 방법을 공유하고자 합니다." }, { "title": "MaterialApp Widget", "url": "/posts/basic-widget-materialApp/", "categories": "Flutter, Basic", "tags": "flutter, Widget", "date": "2022-06-29 17:08:00 +0900", "snippet": "MaterialAppMaterialApp은 이름 그대로 material style의 App widget 가장 바깥 쪽에 위치하는 widget모든 widget은 MaterialApp widget의 하위에 위치Properties가장 많이 사용하는 대표적인 properties title title: 'My App' App의 한 줄 설명 Android의 경우 최근 사용한 앱에 표시 IOS는 의미가 없음 theme theme: ThemeData( // light/dart mode brightness: Brigntness.light, // Primary color primaryColor: Colors.blue, // Font fontFamily: 'Noto-sans',), App의 테마를 구성 home home: Scaffold( appBar: AppBar( title: const Text('MaterialApp'), centerTitle: false, ), body: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Center( child: FloatingActionButton( onPressed: () {}, ), ), ], ),), App 실행 시 최초 화면 Scaffold Widget을 사용하여 정의 Scaffold, AppBar, Column, Center 등은 모두 Widget으로, 다른 section에서 다룸 routes // \"/\"으로 named route와 함께 시작initialRoute: '/',routes: { // \"/\" route로 이동하면 FirstScreen widget을 생성 '/': (context) =&gt; FirstScreen(), // \"/second\" route로 이동하면 SecondScreen widget을 생성 '/second': (context) =&gt; SecondScreen(),} 화면 전환을 위한 properties debugShowCheckedModeBanner debugShowCheckedModeBanner: false // or true 화면 최상단의 debug banner의 유무를 정의 " }, { "title": "Flutter 개요", "url": "/posts/introduction-of-flutter/", "categories": "Flutter, Study", "tags": "flutter", "date": "2022-06-29 13:50:00 +0900", "snippet": "Why Flutter?Cross PlatformIOS, Android, Web, Desktop application을 one source로 구현Performance 대표적으로 비교할 만한 platform은 React-Native(RN)이 있다 과거에는 많은 차이를 보였으나, Hermes engine의 도입으로 native에 근접한 성능을 보인다하여 Flutter가 성능면으로 이점을 갖는 것은 과거의 일이 되었다 네이티브와 비교했을 때, 네이티브보다 빠를 수는 없지만 근접한 성능을 낸다StructureStart Flutter!Environment책 or Web site를 참고공식 사이트:InstallDartMade by Google주요 개념 Variables /*\tDynamic type\tvar: 어떤 형태의 타입도 가질 수 있는 type (like any in javascript)\t선언과 동시에 할당 시 최초 할당한 데이터의 타입으로 고정*/ 선언만 하는 경우 dynamic type -&gt; 추후 할당하더라도 타입 고정이 이뤄지지 않음// 선언 + 할당var a = 1; // Integer typea = 'test'; // Error// 선언var a;a = 1;a = 'test'; // No problem/*\tImplicit type\t- int: 정수형\t- double: 실수형\t- String (S is capital): 문자열\t- bool: true/false\t- List: Python list와 유사\t- Map: Key-value data type (Key has unique value)\t- enum: 열거형*/// String concat -&gt; Javascript stylevar a = 'This';var b = 'is';var c = 'string';var testString = a + ' ' + b + ' ' + c; // Not goodvar testString = '$a $b $c \\\\$'; // Good/* List*/// List First ExampleList&lt;String&gt; fruits = []; // 선언List&lt;String&gt; fruits = List.empty(growable: true); // 선언 2fruits.add('Apple');fruits.add('Banana');fruits.add('Kiwi'); // Item 추가, ['Apple', 'Banana', 'Kiwi']fruits.removeAt(1); // Item 제거, ['Apple', 'Kiwi']// List 선언과 동시에 할당List&lt;String&gt; fruits = ['Apple', 'Banana', 'Kiwi'];List&lt;String&gt; fruits = List.from(['Apple', 'Banana', 'Kiwi']);// 고정 길이 List// 고정된 길이의 List는 add, removeAt 등 List 길이의 변화가 일어나는 함수 사용 불가List&lt;String&gt; fruits = List.filled(3, '');fruits[0] = 'Apple';fruits[1] = 'Banana';fruits[2] = 'Kiwi';/* List Functions */// joinvar oneString = fruits.join(','); // 'AppleBananaKiwi'// indexOfvar bananaIndex = fruits.indexOf('Banana'); // 1// wherevar has_a = fruits.where((fruit) =&gt; fruit.toLowerCase().indexOf('a') &gt;= 0); // has_a = ['Apple', 'Banana']// forEachfruits.forEach((fruit) { // Loop - forEach\tprint(fruit);});// mapIterable&lt;String&gt; newFruits = fruits.map((e) {\treturn 'My ${e}';}); // ['My Apple', 'My Banana', 'My Kiwi']// foldList&lt;int&gt; numbers = [1, 2, 3, 4, 5];int result = numbers.fold(10, (previousValue, element)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t=&gt; (previousValue + element) * 2); // 114// reduceint result = numbers.reduce((value, element) =&gt; value + element); // 15// asMapList&lt;int&gt; numbers = [10, 20, 30, 40, 50];Iterable indexNumbers = numbers.asMap().entries.map((e) { return 'index: ${e.key} / value: ${e.value}';});/* enum*/enum Status {\twait,\tapprove,\treject,}switch (currentStatus) { case Status.wait: break; case Status.approve: break; case Status.reject: break;}/* Constant\t- final: Runtime에 상수가 지정\t- const: Compile time에 상수가 지정*/// Constant Examplefinal DateTime now = DateTime.now(); // OKconst DateTime now = DateTime.now(); // Error - compile time에 값을 알 수 없음/* Nullable: ? - 초기값을 설정하지 않고 변수 선언 가능 (default = null) - null 할당 가능\tNull-aware: ??\t- Means, if null*/String? name;name = 'Luke'; // OKname = null; // OKprofileName = name ?? 'default name';// Search Default parameter Control flow if-else, switch-case for, while Function OOP Class Inheritance Method override Asynchronous Node.js와 유사하게 Single thread + Event loop 형식 dart:isolate library로 Node.js의 worker와 유사하게 구현 가능 Basic of FlutterConceptEverything is Widget화면 안에 모든 요소는 위젯이다 (like React) Class의 형태를 갖는다 (view code)State어떤 상태에 대한 값을 저장하는 변수상태가 변한다 = 이전 상태의 모습에서 현재 상태의 모습으로 바꿔서 보여준다 (re-rendering) Local state: 특정 widget에 국한된 상태 Using stateful widget &amp; setState Global state: 앱 전체를 아우르는 상태 가장 위의 상태를 하위 위젯으로 넘겨주거나, 모듈을 사용하여 해결 (BloC, Provider, GetX, …) Stream흐름데이터를 불러오는 데 시간이 오래 걸리거나, 지속적으로 데이터를 받아야 하는 경우 활용! Flutter 비동기 프로그래밍에서 많이 접하게 될 Future와는 다른 개념Future는 일시적으로 데이터를 받을 때 / Stream은 지속적으로 데이터를 받을 때 Future: async-await + return 구조 → return으로 값을 받고 종료 Stream: async * - await + yield 구조 → yield로 계속 값을 수신 // Stream Exampleimport 'dart:async';Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async {\tvar sum = 0; await for (var value in stream) { \tsum += value; print(sum); } return sum;}Stream&lt;int&gt; countStream(int to) async* {\tfor(int i = 1; i &lt; to; i++) { \tawait Future.delayed(const Duration(seconds:1)); yield i; }}var transformer = StreamTransformer&lt;int, String&gt;.fromHandlers(handleData : (value, sink) {\tsink.add(\"value: $value\");});void main() async {\tvar stream = countStream(10);// stream.transform(transformer).listen((value)=&gt;print(value)); var sum = await sumStream(stream); print(sum);} New projectIn vscode cmd + shift + p (for Mac) ctrl + shift + p (for Windows)Command-line# Flutter project name은 snake-caseflutter create first_appStructure of project살펴볼 요소 pubspec.yaml lib/main.dartpubspec.yamlFlutter project의 메타 정보를 담고 있는 마크업 파일 Project name, descriptions, version, etc… Package pubspec.yaml 파일에 직접 타이핑하여 추가 추가 후, vscode 확장이나 기타 도구를 사용하지 않는 경우 get 명령어로 다운로드를 수행 flutter pub get Command-line 명령어를 통해 추가 # Version을 명시하지 않으면 최신의 모듈을 받아온다flutter pub add 'package name' Image Image resource를 정의하는 부분 Font Image와 동일한 방식으로, 사용하고자 하는 글꼴을 정의하는 부분 lib실제 구현하게 될 dart 코드가 위치하는 폴더 main.dart - Root code" } ]
